plot(x= result$points$x, y= result$points$y, type="n", ann=FALSE, axes=FALSE, asp=1)	# plot
input
# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]
# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}
input
# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)
i<-1
# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		}
new.curve
plot.control
input$lines
plot.control
color.matrix<-col2rgb(plot.control$line.cols)
color.matrix
plot.control$line.cols
color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})
color.matrix.expanded
colours.final<-rgb(color.matrix.expanded, maxColorValue=255)
colours.final
new.curve
# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]{ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}
i
# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]
# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}
colours.final
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function
plot(x= result$points$x, y= result$points$y, type="n", ann=FALSE, axes=FALSE, asp=1)	# plot
draw.curves(result, plot.control) #$points, line.list, line.widths, line.gradient)	# add lines
circleplot(distance.matrix)
# plot functions#
#
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function#
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
	dist2<-as.dist(2-(2* distance.matrix))#
	asymmetry.test<-any(c(dist1==dist2)==FALSE)#
	if(asymmetry.test){distance.matrix<-dist1#
	}else{distance.matrix<-dist2}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 1:7){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function#
# function to use the above code to draw a figure#
circleplot<-function(#
	distance.matrix,	# i.e. a distance matrix (class 'dist') containing binary values#
	plot.control	# a matrix containing any or all of the following compenents:#
		# points = point.attributes, # if given, a data.frame with colnames=c('label', "colour", "size")#
		# lines 	#
			# .gradient - TRUE or FALSE - used to determine whether lines should display a colour gradient#
			# .breaks - vector used to determine the breaks for colours#
			# .colours - vector containing colours. used with 'breaks' above. length= length(breaks)-1#
			# .curvature - a percentage giving the % of maximum sent to gaussian curve#
				# i.e. curvature=1 always has a min=0, max=max, while curvature=0 is equivalent to linear#
				# (formerly line.emphasis - "gaussian" or "linear").#
			# .width = vector if length-1 contains absolute value; if length-2 contains minimum and max#
	# simple	# later, will be passed to prep.binary - whether to draw a complex plot (or not). defaults to TRUE.#
	)#
	{#
	# set plot attributes/defaults#
	plot.control<-check.plot.control(distance.matrix, plot.control, binary.test)#
#
	# run appropriate prep code#
	if(plot.control$properties[1]){	# if binary#
		result<-prep.binary(distance.matrix, plot.control$points)#
	}else{#
		result<-prep.numeric(distance.matrix, plot.control$points)}#
#
	# call plot code#
	par(mar=rep(0.5, 4))	# set window attributes#
	plot(x= result$points$x, y= result$points$y, type="n", ann=FALSE, axes=FALSE, asp=1)	# plot#
	draw.curves(result, plot.control) #$points, line.list, line.widths, line.gradient)	# add lines#
	points(result$points$x, result$points$y, 	# add points#
		pch=19, #
		col= result$points$colour, #
		cex= result$points$size)#
	text(result$points$x, result$points$y, label= result$points$label, col="white", cex=0.7)	# label points#
#
	# if(singletons)add.outer.points#
	}#
# simple code to get pretty point colours#
point.attr<-function(distance.matrix)#
	{#
	#library(RColorBrewer)	# to choose an existing palette#
	labels<-as.character(attr(distance.matrix, "Labels"))#
	color.hex<-c(RColorBrewer::brewer.pal(8, "Dark2"), #
		brewer.pal(9, "Set1"),#
		brewer.pal(8, "Set2")#
		)[1:length(labels)]#
	point.attributes<-data.frame(#
			label= labels,#
			colour=color.hex,#
			size=rep(3, length(labels)),#
			stringsAsFactors=FALSE)#
	}
circleplot(distance.matrix)
# function to use the above code to draw a figure#
circleplot<-function(#
	distance.matrix,	# i.e. a distance matrix (class 'dist') containing binary values#
	plot.control	# a matrix containing any or all of the following compenents:#
		# points = point.attributes, # if given, a data.frame with colnames=c('label', "colour", "size")#
		# lines 	#
			# .gradient - TRUE or FALSE - used to determine whether lines should display a colour gradient#
			# .breaks - vector used to determine the breaks for colours#
			# .colours - vector containing colours. used with 'breaks' above. length= length(breaks)-1#
			# .curvature - a percentage giving the % of maximum sent to gaussian curve#
				# i.e. curvature=1 always has a min=0, max=max, while curvature=0 is equivalent to linear#
				# (formerly line.emphasis - "gaussian" or "linear").#
			# .width = vector if length-1 contains absolute value; if length-2 contains minimum and max#
	# simple	# later, will be passed to prep.binary - whether to draw a complex plot (or not). defaults to TRUE.#
	)#
	{#
	# set plot attributes/defaults#
	plot.control<-check.plot.control(distance.matrix, plot.control)#
#
	# run appropriate prep code#
	if(plot.control$properties[1]){	# if binary#
		result<-prep.binary(distance.matrix, plot.control$points)#
	}else{#
		result<-prep.numeric(distance.matrix, plot.control$points)}#
#
	# call plot code#
	par(mar=rep(0.5, 4))	# set window attributes#
	plot(x= result$points$x, y= result$points$y, type="n", ann=FALSE, axes=FALSE, asp=1)	# plot#
	draw.curves(result, plot.control) #$points, line.list, line.widths, line.gradient)	# add lines#
	points(result$points$x, result$points$y, 	# add points#
		pch=19, #
		col= result$points$colour, #
		cex= result$points$size)#
	text(result$points$x, result$points$y, label= result$points$label, col="white", cex=0.7)	# label points#
#
	# if(singletons)add.outer.points#
	}
circleplot(distance.matrix)
circleplot(distance.matrix, list(line.cols=c("grey80", "red")))
circleplot(distance.matrix, list(line.cols=c("blue", "red")))
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=30)})#
				color.matrix.expanded<-c(color.matrix.expanded, rep(color.matrix.expanded[30], 70)#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=30)})#
				color.matrix.expanded<-c(color.matrix.expanded, rep(color.matrix.expanded[30], 70))#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function
circleplot(distance.matrix, list(line.cols=c("blue", "red")))
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=30)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				color.matrix.expanded<-c(color.matrix.expanded, rep(color.matrix.expanded[30], 70))#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function
circleplot(distance.matrix, list(line.cols=c("blue", "red")))
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=30)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				colours.final<-c(colours.final, rep(colours.final[30], 70))#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function
circleplot(distance.matrix, list(line.cols=c("blue", "red")))
distance.matrix
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=30)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				colours.final<-c(rep(colours.final[1], 70), colours.final)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function
circleplot(distance.matrix, list(line.cols=c("blue", "red")))
circleplot(distance.matrix, list(line.cols=c("grey", "red")))
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=50)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				colours.final<-c(rep(colours.final[1], 50), colours.final)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function
circleplot(distance.matrix, list(line.cols=c("grey", "red")))
circleplot(distance.matrix, list(line.cols=c("grey", "blue")))
distance.matrix
circleplot(test.dist2, plot.control=list(#
	points=point.attributes,#
	line.gradient=TRUE,#
	line.curvature=0.6,#
	line.width=3))
test.points<-matrix(data=rnorm(22), nrow=11, ncol=2)#
test.dist<-as.dist(scale(dist(test.points)))#
#
# make binary matrix from this continuous matrix, for example purposes only#
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, 0, 20), labels=FALSE)-1#
#
# directional binary matrix#
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)#
for(i in 1:dim(distance.matrix)[1]){distance.matrix[i, i]<-NA}#
#
# adirecional#
test.dist2<-as.dist(distance.matrix)#
# set point colours for either matrix (as both have same dimensions)#
point.attributes<-point.attr(test.dist)#
#
# try a directional matrix
library(RColorBrewer)
test.points<-matrix(data=rnorm(22), nrow=11, ncol=2)#
test.dist<-as.dist(scale(dist(test.points)))#
#
# make binary matrix from this continuous matrix, for example purposes only#
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, 0, 20), labels=FALSE)-1#
#
# directional binary matrix#
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)#
for(i in 1:dim(distance.matrix)[1]){distance.matrix[i, i]<-NA}#
#
# adirecional#
test.dist2<-as.dist(distance.matrix)#
# set point colours for either matrix (as both have same dimensions)#
point.attributes<-point.attr(test.dist)#
#
# try a directional matrix
circleplot(test.dist2, plot.control=list(line.curvature=0, line.width=1))
circleplot(test.dist2, plot.control=list(#
	points=point.attributes,#
	line.gradient=TRUE,#
	line.curvature=0.6,#
	line.width=3))
circleplot(test.dist, plot.control=list(#
	line.breaks=c(-10, -1, -0.5, 0, 0.5, 1, 10),#
	line.cols=brewer.pal(6, "RdBu"),#
	line.curvature=0,#
	line.width=c(0.5, 2)))
# a continuous plot with curvature#
circleplot(test.dist, plot.control=list(#
	points=point.attributes,#
	line.breaks=c(-10, -1, -0.5, 0, 0.5, 1, 10),#
	line.cols=brewer.pal(6, "RdBu"),#
	line.curvature=0.8,#
	line.width=c(1, 5)))
circleplot(distance.matrix, list(line.cols=c("grey", "blue")))
circleplot(distance.matrix, list(#
	line.cols=c("grey", "blue"),#
	line.width=2#
	))
par(mfrow=c(2, 2))#
#
# simple plot of a binary matrix#
circleplot(test.dist2, plot.control=list(line.curvature=0, line.width=1))#
#
# lines set a gradient in point colours#
circleplot(test.dist2, plot.control=list(#
	points=point.attributes,#
	line.gradient=TRUE,#
	line.curvature=0.6,#
	line.width=3))#
#
# without curvature#
circleplot(test.dist, plot.control=list(#
	line.breaks=c(-10, -1, -0.5, 0, 0.5, 1, 10),#
	line.cols=brewer.pal(6, "RdBu"),#
	line.curvature=0,#
	line.width=c(0.5, 2)))#
#
# a continuous plot with curvature#
circleplot(test.dist, plot.control=list(#
	points=point.attributes,#
	line.breaks=c(-10, -1, -0.5, 0, 0.5, 1, 10),#
	line.cols=brewer.pal(6, "RdBu"),#
	line.curvature=0.8,#
	line.width=c(1, 5)))#
#
par(mfrow=c(1, 1))
circleplot(distance.matrix, list(#
	line.cols=c("paleblue", "blue"),#
	line.width=2#
	))
colours
colours()
circleplot(distance.matrix, list(#
	line.cols=c("lightblue1", "blue"),#
	line.width=2#
	))
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
test.points<-matrix(data=rnorm(22), nrow=11, ncol=2)#
test.dist<-as.dist(scale(dist(test.points)))#
#
# make binary matrix from this continuous matrix, for example purposes only#
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, 0, 20), labels=FALSE)-1#
#
# directional binary matrix#
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, -0.4, 20), labels=FALSE)-1
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, 0.5, 20), labels=FALSE)-1
# directional binary matrix#
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)#
#for(i in 1:dim(distance.matrix)[1]){distance.matrix[i, i]<-NA}#
#
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, 0.7, 20), labels=FALSE)-1
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, 0.6, 20), labels=FALSE)-1
# directional binary matrix#
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)#
#for(i in 1:dim(distance.matrix)[1]){distance.matrix[i, i]<-NA}#
#
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
result
plot.control
distance.matrix
# trigonometric functions for circleplot#
#
# make a circle of specified size#
make.circle<-function(#
	n,	# number of points, equally spaced around the edge of a circle#
	alpha,	# offset angle, in radians#
	k)	# scaling value - larger for bigger circles. defaults to 1#
	{#
	if(missing(k))k<-1#
	if(missing(alpha))alpha<-0.4#
	# create output dataframe#
	values<-as.data.frame(matrix(data=NA, nrow=n, ncol=3))#
		colnames(values)<-c("theta", "x", "y")#
	for(i in 1:n)	# run loop to calculate all points#
		{#
		values$theta[i]<-(2*(pi/n)*seq(0, (n-1))[i])-alpha#
		values$x[i]<-k*cos(values$theta[i])#
		values$y[i]<-k*sin(values$theta[i])#
		}#
	return(values)#
	}#
# calculate the attributes of a triangle linking two points on the circumference and a point bisecting them, #
	# pc.scale gives the proportion of the distance between the base line and the origin#
# line linking the two points is taken to be horizontal#
triangle.coords<-function(coords, pc.scale=0.5)#
	{#
	radius<-sqrt(coords$x[1]**2 + coords$y[1]**2)#
	base.length<-sqrt((coords$x[1]-coords$x[2])**2 + (coords$y[1]-coords$y[2])**2)#
	adj<-base.length/2#
	adj.on.radius<-adj/radius#
	if(adj.on.radius<1){#
		angle1<-acos(adj.on.radius)#
		opp<-tan(angle1)*adj*pc.scale#
	}else{opp<-0}#
	coords.adjusted<-data.frame(x=c(-adj, 0, adj), y=c(0, opp, 0))#
	return(coords.adjusted)#
	}#
# find the apex of the curve linking coords (i.e. triangle1(points)[2, ])#
curve.apex<-function(coords, pc.scale=0.5)#
	{#
	mean.point<-c(x=mean(coords$x), y=mean(coords$y))#
	angle2<-atan(mean.point[2]/mean.point[1])	# angle between 0,0 and mean.point#
	#	angle2*(180/pi)#
	hyp<-sqrt(mean.point[1]^2+ mean.point[2]^2)*pc.scale#
	adj<-as.numeric(hyp*cos(angle2))#
	opp<-as.numeric(hyp*sin(angle2))#
	result<-data.frame(#
		x=c(mean.point[1], as.numeric(mean.point[1]-(adj*sign(mean.point[1])))), #
		y=c(mean.point[2], as.numeric(mean.point[2]-(opp*sign(mean.point[1])))))#
		# note: *sign() necessary to avoid -ve x vals giving apex(s) that are outside of the cirlce#
	rownames(result)<-c("mean", "apex")#
	output<-list(as.numeric(angle2), result)#
		names(output)<-c("angle", "coordinates")#
	return(output)#
	}#
# find a circle that matches points given by triangle.coords() - NOT IMPLEMENTED#
fit.circle<-function(coords){#
	y.diff<-((coords$x[1]^2)-(coords$y[2]^2))/(2*coords$y[2])#
	radius<-y.diff+coords$y[2]#
	x.vals<-seq(min(coords$x), max(coords$x), length.out=101)	# make an odd number for rotation#
	y.vals<-sqrt((radius^2)-(x.vals^2))#
	y.vals<-y.vals-y.vals[1]#
	curve.coordinates<-data.frame(x=x.vals, y=y.vals)#
	return(curve.coordinates)#
	}#
# fit a quadratic function to points given by triangle.coords()#
fit.quadratic<-function(coords)#
	{#
	model<-lm(y~x+I(x**2), data=coords)#
	newdata<-data.frame(x=seq(min(coords$x), max(coords$x), length.out=101))#
	newdata$y<-as.numeric(predict(model, newdata, se.fit=FALSE))#
	return(newdata)#
	}#
# take curved line give by fit.quadratic(), and rotate to the angle given by curve.apex()#
reposition.curve<-function(#
	curve,	# data.frame returned by fit.circle#
	apex		# list returned by curve.apex#
	)#
	{#
	adjusted.angle<-apex$angle-(90*pi/180)	# becuase your curve faces down, not right#
	# if(apex$coordinates$x[2]>0){adjusted.angle<-adjusted.angle+(pi/180)}#
	curve$y<-curve$y-curve$y[51]	# set apex =0,0#
	if(apex$coordinates$x[2]<0){#
		x.new<-(curve$x*cos(adjusted.angle))-(curve$y*sin(adjusted.angle))	# calculate transformation#
		y.new<-(curve$x*sin(adjusted.angle))+(curve$y*cos(adjusted.angle))#
	}else{#
		x.new<-(curve$x*cos(adjusted.angle))+(curve$y*sin(adjusted.angle))	# calculate transformation#
		y.new<-(curve$x*sin(adjusted.angle))-(curve$y*cos(adjusted.angle))#
	}#
	curve.new<-data.frame(x=x.new, y=y.new)		# put in new dataframe#
	curve.new$x<-curve.new$x+apex$coordinates$x[2]	# position to new x,y#
	curve.new$y<-curve.new$y+apex$coordinates$y[2]	#
	return(curve.new)#
	}
# Set of functions to prepare input objects for plotting. Returns a set of usable point and line attributes.#
#
# internal function for arranging points for plotting binary matrices. This does all of the work in the current version.#
inner.circle<-function(#
	dataset,#
	point.attributes,#
	simple#
	)#
	{#
	# set behaviour for included points#
	if(simple){min.value<-0}else{min.value<-1}#
#
	# subset to only points >min mentions (over both rows and cols - important for asymmetric matrices)#
	keep.rows<-as.numeric(which(apply(dataset, 1, FUN=function(x){sum(x, na.rm=TRUE)})>min.value))#
	keep.cols<-as.numeric(which(apply(dataset, 2, FUN=function(x){sum(x, na.rm=TRUE)})>min.value))	#
	keep.units<-sort(unique(c(keep.rows, keep.cols)))#
	dataset<-dataset[keep.rows, keep.rows]#
#
	# make a distance matrix that functions for both symmetric and asymmetric matrices#
	dataset.dist<-as.dist(2-(dataset+t(dataset))) # t() stage important for asymmetric matrices#
	data.names<-attr(dataset.dist, "Labels")#
#
	# if point attributes are set by default, these will be too large; reduce to appropriate size#
	if(dim(point.attributes)[1]>dim(dataset)[1]){#
		point.attributes<-merge(point.attributes, #
			data.frame(label= data.names, stringsAsFactors=FALSE),#
			by="label", all=FALSE)#
		rownames(point.attributes)<-point.attributes$label#
		}#
#
	# make points for plotting#
	# circle.points<-circle.point.arrangement(dataset)#
	circle.points<-as.data.frame(make.circle(attr(dataset.dist, "Size"))[, 2:3])#
	cluster.result<-hclust(dataset.dist)#
	circle.points$label<-attr(dataset.dist, "Labels")[cluster.result$order]#
		circle.points$label<-as.character(circle.points$label)#
	circle.points<-circle.points[order(circle.points$label), ]#
#
	# now make line dataset to allow drawing of lines#
	# point.connections<-as.dist(dataset) # replaced with dataset.dist#
	# point.names<-attr(point.connections, "Labels")#
	line.list<-as.data.frame(cbind(t(combn(data.names, 2)), as.numeric(dataset.dist)))#
		colnames(line.list)<-c("sp1", "sp2", "value")#
		for(i in 1:2){line.list[, i]<-as.character(line.list[, i])}#
	line.list$value<-2-as.numeric(as.character(line.list$value))		# how many connections#
#
	# determine the direction of these connections#
	direction.matrix<-as.dist(dataset)-as.dist(t(dataset))#
	direction.matrix[which(direction.matrix==0)]<-1#
	line.list$value<-line.list$value*as.numeric(direction.matrix)#
#
	# remove 'absent' connections#
	line.list<-line.list[-which(line.list$value==0), ]#
#
	# add attributes to circle locations#
	circle.points<-merge(circle.points, point.attributes, by="label")#
		circle.points<-circle.points[, c(2, 3, 1, 4, 5)]#
		rownames(circle.points)<-circle.points$label#
#
	# export#
	return(list(points=circle.points, lines=line.list))#
	}#
# anouther function for plotting binary matrices - NOT IMPLEMENTED YET#
# this will be used to add 'singletons' to an outer edge of points in circleplot().#
outer.circle<-function(#
	dataset,	# simple conversion from an adjavency matrix#
	initial.points	# result from inner.circle()#
	)#
	{#
	excluded.rows<-as.numeric(which(apply(dataset, 1, sum)==1))#
	n.points<-length(excluded.rows)#
#
	# look at excluded information - i.e. those with only one connection#
	cols.thisrun<-apply(dataset[excluded.rows, ], 1, function(x){which(x>0)})#
	single.connections<-data.frame(#
		initial=colnames(dataset)[cols.thisrun],#
		final=names(cols.thisrun), stringsAsFactors=FALSE)#
#
	# convert this to a frequency table#
	reduced.points<-xtabs(rep(1, dim(single.connections)[1])~ single.connections$initial)#
	reduced.points<-data.frame(#
		label=names(reduced.points),#
		freq=as.numeric(reduced.points))#
	reduced.points<-reduced.points[order(reduced.points$freq, decreasing=TRUE), ]#
#
	# work out how large the new circle needs to be not to look out of place#
	interpoint.dist<-min(dist(initial.points$points[, 1:2]))#
	n.total<-ceiling((pi*3)/interpoint.dist)#
	if(n.total>n.points){final.n<-n.total}else{final.n<-n.points}#
	circle2<-make.circle(n.total, k=1.5)[, 2:3]#
		circle2$label.inital<-rep("none", dim(circle2)[1])#
		circle2$label.final<-rep("none", dim(circle2)[1])#
		circle2$allocated<-rep(0, dim(circle2)[1])#
#
	# determine which points in circle2 should be assigned to each final point#
	for(i in 1:dim(reduced.points)[1])#
		{#
		initial.thisrun<-which(initial.points$points$label==reduced.points$label[i])#
		values<-initial.points$points[initial.thisrun, ]#
		# work out which (remaining) points are closest#
		point.distances<-rep(NA, final.n)#
		for(j in 1:length(point.distances)){#
			point.distances[j]<-sqrt((circle2$x[j]-values$x)^2 + (circle2$y[j]-values$y)^2)}#
		points.thisrun<-order(point.distances[which(circle2$allocated==0)], #
			decreasing=TRUE)[1: reduced.points$freq[i]]#
#
		# export this information#
		circle2$allocated[points.thisrun]<-1#
		circle2$label.inital[points.thisrun]<-values$label#
		circle2$label.final[points.thisrun]<-single.connections$final[which(single.connections$initial==values$label)]#
		}	#end i#
#
	# remove irrelevant rows/columns from circle2#
	circle2<-circle2[which(circle2$allocated==1), 1:4]#
	return(list(points=circle2, frequencies= reduced.points))#
	}#
# get binary data into an appropriate format for plotting#
# this is called by plot.curves() via draw.circle(), and uses draw.curves() to actually add the segments. #
prep.binary<-function(#
	adjacency.matrix, #
	point.attributes,#
	simple	# should this be a simple (1 circle) or complex (2 circles) plot? 2 circle version incomplete#
	)#
	{#
	if(missing(simple))simple<-TRUE#
	# take adjacency matrix, identify groups with many connections#
	dataset<-as.matrix(adjacency.matrix)#
	# apply(dataset, 1, sum)==apply(dataset, 2, sum) # can use row or col sums#
#
	# calculate points/lines#
	result<-inner.circle(dataset, point.attributes, simple)#
	if(simple==FALSE){#
		added.points<-outer.circle(dataset, initial.points)#
		result$outer.circle=added.points$points#
		result$outer.freq=added.points$freq#
		}#
#
	return(result)#
	}	# end function#
# function to prepare data for analysis if input matrix is numeric#
prep.numeric<-function(#
	numeric.matrix, #
	point.attributes#
	)#
	{#
	point.names<-attr(numeric.matrix, "Labels")	#
#
	# point info prep (Note: could add a clustering algorithm here to better represent inter-point relationships)#
	circle.points<-as.data.frame(make.circle(attr(numeric.matrix, "Size"))[, 2:3])#
	# work out point order using clustering#
	connection.distance<-as.dist(1-(sqrt(numeric.matrix^2)))#
	result<-hclust(connection.distance)#
	circle.points$label<-point.names[result$order]#
#
	# add point attributes#
	circle.points<-merge(circle.points, point.attributes, by="label")#
		circle.points<-circle.points[, c(2, 3, 1, 4, 5)]#
		rownames(circle.points)<-circle.points$label#
#
	# line info prep#
	line.list<-as.data.frame(cbind(t(combn(point.names, 2)), as.vector(numeric.matrix)), #
		stringsAsFactors=FALSE)#
	colnames(line.list)<-c("sp1", "sp2", "value")#
	line.list$value<-as.numeric(line.list$value)#
#
	# order line list by effect size#
	effect.size<-line.list$value^2#
	line.list<-line.list[order(effect.size), ]#
#
	return(list(points=circle.points, lines=line.list))#
	}
# plot functions#
#
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=50)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				colours.final<-c(rep(colours.final[1], 50), colours.final)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
			# NOTE: These properties can be set out of the loop#
				# There is still a need to plot different line colours depending on input$lines$value#
				# =2 means rep(plot.control$line.cols[2], 100)	#
				# =-1 means reverse the direction of the plot#
				# then checking required to ensure directions are correct. #
			# might also need to ensure input matrix has NA diagonals#
			# finally, it should be easy to allow data.frame as input uning make.wide()#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function#
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
	dist2<-as.dist(2-(2* distance.matrix))#
	asymmetry.test<-any(c(dist1==dist2)==FALSE)#
	if(asymmetry.test){distance.matrix<-dist1#
	}else{distance.matrix<-dist2}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 1:7){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function#
# function to use the above code to draw a figure#
circleplot<-function(#
	distance.matrix,	# i.e. a distance matrix (class 'dist') containing binary values#
	plot.control	# a matrix containing any or all of the following compenents:#
		# points = point.attributes, # if given, a data.frame with colnames=c('label', "colour", "size")#
		# lines 	#
			# .gradient - TRUE or FALSE - used to determine whether lines should display a colour gradient#
			# .breaks - vector used to determine the breaks for colours#
			# .colours - vector containing colours. used with 'breaks' above. length= length(breaks)-1#
			# .curvature - a percentage giving the % of maximum sent to gaussian curve#
				# i.e. curvature=1 always has a min=0, max=max, while curvature=0 is equivalent to linear#
				# (formerly line.emphasis - "gaussian" or "linear").#
			# .width = vector if length-1 contains absolute value; if length-2 contains minimum and max#
	# simple	# later, will be passed to prep.binary - whether to draw a complex plot (or not). defaults to TRUE.#
	)#
	{#
	# set plot attributes/defaults#
	plot.control<-check.plot.control(distance.matrix, plot.control)#
#
	# run appropriate prep code#
	if(plot.control$properties[1]){	# if binary#
		result<-prep.binary(distance.matrix, plot.control$points)#
	}else{#
		result<-prep.numeric(distance.matrix, plot.control$points)}#
#
	# call plot code#
	par(mar=rep(0.5, 4))	# set window attributes#
	plot(x= result$points$x, y= result$points$y, type="n", ann=FALSE, axes=FALSE, asp=1)	# plot#
	draw.curves(result, plot.control) #$points, line.list, line.widths, line.gradient)	# add lines#
	points(result$points$x, result$points$y, 	# add points#
		pch=19, #
		col= result$points$colour, #
		cex= result$points$size)#
	text(result$points$x, result$points$y, label= result$points$label, col="white", cex=0.7)	# label points#
#
	# if(singletons)add.outer.points#
	}#
# simple code to get pretty point colours#
point.attr<-function(distance.matrix)#
	{#
	#library(RColorBrewer)	# to choose an existing palette#
	labels<-as.character(attr(distance.matrix, "Labels"))#
	color.hex<-c(RColorBrewer::brewer.pal(8, "Dark2"), #
		brewer.pal(9, "Set1"),#
		brewer.pal(8, "Set2")#
		)[1:length(labels)]#
	point.attributes<-data.frame(#
			label= labels,#
			colour=color.hex,#
			size=rep(3, length(labels)),#
			stringsAsFactors=FALSE)#
	}
# create an example:#
# a continuous matrix#
test.points<-matrix(data=rnorm(22), nrow=11, ncol=2)#
test.dist<-as.dist(scale(dist(test.points)))#
#
# make binary matrix from this continuous matrix, for example purposes only#
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, 0, 20), labels=FALSE)-1#
#
# directional binary matrix#
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)#
for(i in 1:dim(distance.matrix)[1]){distance.matrix[i, i]<-NA}
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
plot.control<-check.plot.control(distance.matrix)#, plot.control)
result<-prep.binary(distance.matrix, plot.control$points)
result
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=50)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				colours.final<-c(rep(colours.final[1], 50), colours.final)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
			# NOTE: These properties can be set out of the loop#
				# There is still a need to plot different line colours depending on input$lines$value#
				# =2 means rep(plot.control$line.cols[2], 100)	#
				# =-1 means reverse the direction of the plot#
				# then checking required to ensure directions are correct. #
			# might also need to ensure input matrix has NA diagonals#
			# finally, it should be easy to allow data.frame as input uning make.wide()#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
					# reverse if order is wrong#
					if(result$lines$value[i]==-1){colours.final<-colours.final[100:1]}		#
					if(result$lines$value[i]==2){colours.final<-rep(colours.final[100], 100)}				#
#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function#
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
	dist2<-as.dist(2-(2* distance.matrix))#
	asymmetry.test<-any(c(dist1==dist2)==FALSE)#
	if(asymmetry.test){distance.matrix<-dist1#
	}else{distance.matrix<-dist2}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 1:7){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
# plot functions#
#
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=50)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				colours.final<-c(rep(colours.final[1], 50), colours.final)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
			# NOTE: These properties can be set out of the loop#
				# There is still a need to plot different line colours depending on input$lines$value#
				# =2 means rep(plot.control$line.cols[2], 100)	#
				# =-1 means reverse the direction of the plot#
				# then checking required to ensure directions are correct. #
			# might also need to ensure input matrix has NA diagonals#
			# finally, it should be easy to allow data.frame as input uning make.wide()#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
					# reverse if order is wrong#
					if(result$lines$value[i]==-1){colours.final<-colours.final[100:1]}		#
					if(result$lines$value[i]==2){colours.final<-rep(colours.final[100], 100)}				#
#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function#
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
	dist2<-as.dist(2-(2* distance.matrix))#
	asymmetry.test<-any(c(dist1==dist2)==FALSE)#
	if(asymmetry.test){distance.matrix<-dist1#
	}else{distance.matrix<-dist2}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 1:7){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function#
# function to use the above code to draw a figure#
circleplot<-function(#
	distance.matrix,	# i.e. a distance matrix (class 'dist') containing binary values#
	plot.control	# a matrix containing any or all of the following compenents:#
		# points = point.attributes, # if given, a data.frame with colnames=c('label', "colour", "size")#
		# lines 	#
			# .gradient - TRUE or FALSE - used to determine whether lines should display a colour gradient#
			# .breaks - vector used to determine the breaks for colours#
			# .colours - vector containing colours. used with 'breaks' above. length= length(breaks)-1#
			# .curvature - a percentage giving the % of maximum sent to gaussian curve#
				# i.e. curvature=1 always has a min=0, max=max, while curvature=0 is equivalent to linear#
				# (formerly line.emphasis - "gaussian" or "linear").#
			# .width = vector if length-1 contains absolute value; if length-2 contains minimum and max#
	# simple	# later, will be passed to prep.binary - whether to draw a complex plot (or not). defaults to TRUE.#
	)#
	{#
	# set plot attributes/defaults#
	plot.control<-check.plot.control(distance.matrix, plot.control)#
#
	# run appropriate prep code#
	if(plot.control$properties[1]){	# if binary#
		result<-prep.binary(distance.matrix, plot.control$points)#
	}else{#
		result<-prep.numeric(distance.matrix, plot.control$points)}#
#
	# call plot code#
	par(mar=rep(0.5, 4))	# set window attributes#
	plot(x= result$points$x, y= result$points$y, type="n", ann=FALSE, axes=FALSE, asp=1)	# plot#
	draw.curves(result, plot.control) #$points, line.list, line.widths, line.gradient)	# add lines#
	points(result$points$x, result$points$y, 	# add points#
		pch=19, #
		col= result$points$colour, #
		cex= result$points$size)#
	text(result$points$x, result$points$y, label= result$points$label, col="white", cex=0.7)	# label points#
#
	# if(singletons)add.outer.points#
	}#
# simple code to get pretty point colours#
point.attr<-function(distance.matrix)#
	{#
	#library(RColorBrewer)	# to choose an existing palette#
	labels<-as.character(attr(distance.matrix, "Labels"))#
	color.hex<-c(RColorBrewer::brewer.pal(8, "Dark2"), #
		brewer.pal(9, "Set1"),#
		brewer.pal(8, "Set2")#
		)[1:length(labels)]#
	point.attributes<-data.frame(#
			label= labels,#
			colour=color.hex,#
			size=rep(3, length(labels)),#
			stringsAsFactors=FALSE)#
	}
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
# plot functions#
#
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=50)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				colours.final<-c(rep(colours.final[1], 50), colours.final)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				# reverse if order is wrong#
				if(result$lines$value[i]==-1){colours.final<-colours.final[100:1]}		#
				if(result$lines$value[i]==2){colours.final<-rep(colours.final[100], 100)}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}		#
#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function#
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
	dist2<-as.dist(2-(2* distance.matrix))#
	asymmetry.test<-any(c(dist1==dist2)==FALSE)#
	if(asymmetry.test){distance.matrix<-dist1#
	}else{distance.matrix<-dist2}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 1:7){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function#
# function to use the above code to draw a figure#
circleplot<-function(#
	distance.matrix,	# i.e. a distance matrix (class 'dist') containing binary values#
	plot.control	# a matrix containing any or all of the following compenents:#
		# points = point.attributes, # if given, a data.frame with colnames=c('label', "colour", "size")#
		# lines 	#
			# .gradient - TRUE or FALSE - used to determine whether lines should display a colour gradient#
			# .breaks - vector used to determine the breaks for colours#
			# .colours - vector containing colours. used with 'breaks' above. length= length(breaks)-1#
			# .curvature - a percentage giving the % of maximum sent to gaussian curve#
				# i.e. curvature=1 always has a min=0, max=max, while curvature=0 is equivalent to linear#
				# (formerly line.emphasis - "gaussian" or "linear").#
			# .width = vector if length-1 contains absolute value; if length-2 contains minimum and max#
	# simple	# later, will be passed to prep.binary - whether to draw a complex plot (or not). defaults to TRUE.#
	)#
	{#
	# set plot attributes/defaults#
	plot.control<-check.plot.control(distance.matrix, plot.control)#
#
	# run appropriate prep code#
	if(plot.control$properties[1]){	# if binary#
		result<-prep.binary(distance.matrix, plot.control$points)#
	}else{#
		result<-prep.numeric(distance.matrix, plot.control$points)}#
#
	# call plot code#
	par(mar=rep(0.5, 4))	# set window attributes#
	plot(x= result$points$x, y= result$points$y, type="n", ann=FALSE, axes=FALSE, asp=1)	# plot#
	draw.curves(result, plot.control) #$points, line.list, line.widths, line.gradient)	# add lines#
	points(result$points$x, result$points$y, 	# add points#
		pch=19, #
		col= result$points$colour, #
		cex= result$points$size)#
	text(result$points$x, result$points$y, label= result$points$label, col="white", cex=0.7)	# label points#
#
	# if(singletons)add.outer.points#
	}#
# simple code to get pretty point colours#
point.attr<-function(distance.matrix)#
	{#
	#library(RColorBrewer)	# to choose an existing palette#
	labels<-as.character(attr(distance.matrix, "Labels"))#
	color.hex<-c(RColorBrewer::brewer.pal(8, "Dark2"), #
		brewer.pal(9, "Set1"),#
		brewer.pal(8, "Set2")#
		)[1:length(labels)]#
	point.attributes<-data.frame(#
			label= labels,#
			colour=color.hex,#
			size=rep(3, length(labels)),#
			stringsAsFactors=FALSE)#
	}
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
plot.control
result
plot.control
# plot functions#
#
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=50)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				colours.final<-c(rep(colours.final[1], 50), colours.final)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				# reverse if order is wrong#
				if(result$lines$value[i]==-1){colours.final<-colours.final[100:1]}		#
				if(result$lines$value[i]==2){colours.final<-rep(plot.control$line.cols[2], 100)}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}		#
#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function#
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
	dist2<-as.dist(2-(2* distance.matrix))#
	asymmetry.test<-any(c(dist1==dist2)==FALSE)#
	if(asymmetry.test){distance.matrix<-dist1#
	}else{distance.matrix<-dist2}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 1:7){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function#
# function to use the above code to draw a figure#
circleplot<-function(#
	distance.matrix,	# i.e. a distance matrix (class 'dist') containing binary values#
	plot.control	# a matrix containing any or all of the following compenents:#
		# points = point.attributes, # if given, a data.frame with colnames=c('label', "colour", "size")#
		# lines 	#
			# .gradient - TRUE or FALSE - used to determine whether lines should display a colour gradient#
			# .breaks - vector used to determine the breaks for colours#
			# .colours - vector containing colours. used with 'breaks' above. length= length(breaks)-1#
			# .curvature - a percentage giving the % of maximum sent to gaussian curve#
				# i.e. curvature=1 always has a min=0, max=max, while curvature=0 is equivalent to linear#
				# (formerly line.emphasis - "gaussian" or "linear").#
			# .width = vector if length-1 contains absolute value; if length-2 contains minimum and max#
	# simple	# later, will be passed to prep.binary - whether to draw a complex plot (or not). defaults to TRUE.#
	)#
	{#
	# set plot attributes/defaults#
	plot.control<-check.plot.control(distance.matrix, plot.control)#
#
	# run appropriate prep code#
	if(plot.control$properties[1]){	# if binary#
		result<-prep.binary(distance.matrix, plot.control$points)#
	}else{#
		result<-prep.numeric(distance.matrix, plot.control$points)}#
#
	# call plot code#
	par(mar=rep(0.5, 4))	# set window attributes#
	plot(x= result$points$x, y= result$points$y, type="n", ann=FALSE, axes=FALSE, asp=1)	# plot#
	draw.curves(result, plot.control) #$points, line.list, line.widths, line.gradient)	# add lines#
	points(result$points$x, result$points$y, 	# add points#
		pch=19, #
		col= result$points$colour, #
		cex= result$points$size)#
	text(result$points$x, result$points$y, label= result$points$label, col="white", cex=0.7)	# label points#
#
	# if(singletons)add.outer.points#
	}#
# simple code to get pretty point colours#
point.attr<-function(distance.matrix)#
	{#
	#library(RColorBrewer)	# to choose an existing palette#
	labels<-as.character(attr(distance.matrix, "Labels"))#
	color.hex<-c(RColorBrewer::brewer.pal(8, "Dark2"), #
		brewer.pal(9, "Set1"),#
		brewer.pal(8, "Set2")#
		)[1:length(labels)]#
	point.attributes<-data.frame(#
			label= labels,#
			colour=color.hex,#
			size=rep(3, length(labels)),#
			stringsAsFactors=FALSE)#
	}
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
distance.matrix
result
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "blue"),#
	line.width=2#
	))
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "red"),#
	line.width=2#
	))
line.cols=c("lightblue2", "steelblue"),
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "steelblue"),#
	line.width=2#
	))
circleplot(distance.matrix)#, list(
# create an example:#
# a continuous matrix#
test.points<-matrix(data=rnorm(22), nrow=11, ncol=2)#
test.dist<-as.dist(scale(dist(test.points)))#
#
# make binary matrix from this continuous matrix, for example purposes only#
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, 0, 20), labels=FALSE)-1#
#
# directional binary matrix#
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)#
for(i in 1:dim(distance.matrix)[1]){distance.matrix[i, i]<-NA}#
#
# adirecional#
test.dist2<-as.dist(distance.matrix)#
# set point colours for either matrix (as both have same dimensions)#
point.attributes<-point.attr(test.dist)
library(RColorBrewer)
circleplot(test.dist2, plot.control=list(line.curvature=0, line.width=1))
# lines set a gradient in point colours#
circleplot(test.dist2, plot.control=list(#
	points=point.attributes,#
	line.gradient=TRUE,#
	line.curvature=0.6,#
	line.width=3))
point.attributes<-point.attr(test.dist)
# lines set a gradient in point colours#
circleplot(test.dist2, plot.control=list(#
	points=point.attributes,#
	line.gradient=TRUE,#
	line.curvature=0.6,#
	line.width=3))
# without curvature#
circleplot(test.dist, plot.control=list(#
	line.breaks=c(-10, -1, -0.5, 0, 0.5, 1, 10),#
	line.cols=brewer.pal(6, "RdBu"),#
	line.curvature=0,#
	line.width=c(0.5, 2)))
points=point.attributes,#
	line.gradient=TRUE,#
	line.curvature=0.6,#
	line.width=3))#
#
# without curvature#
circleplot(test.dist, plot.control=list(#
	line.breaks=c(-10, -1, -0.5, 0, 0.5, 1, 10),#
	line.cols=brewer.pal(6, "RdBu"),#
	line.curvature=0,#
	line.width=c(0.5, 2)))#
#
# a continuous plot with curvature#
circleplot(test.dist, plot.control=list(#
	points=point.attributes,#
	line.breaks=c(-10, -1, -0.5, 0, 0.5, 1, 10),#
	line.cols=brewer.pal(6, "RdBu"),#
	line.curvature=0.8,#
	line.width=c(1, 5)))
test.points<-matrix(data=rnorm(22), nrow=11, ncol=2)#
test.dist<-as.dist(scale(dist(test.points)))
test.dist
test.points<-matrix(data=rnorm(22), nrow=11, ncol=2)
test.points
for(i in 1:dim(distance.numeric)[1]){distance.numeric[i, i]<-NA}
distance.numeric<-matrix(data=rnorm(22), nrow=11, ncol=2)#
for(i in 1:dim(distance.numeric)[1]){distance.numeric[i, i]<-NA}
distance.numeric
distance.numeric<-matrix(data=rnorm(22), nrow=11, ncol=11)
for(i in 1:dim(distance.numeric)[1]){distance.numeric[i, i]<-NA}
distance.numeric
plot.control<-check.plot.control(distance.matrix)
plot.control<-check.plot.control(distance.numeric)
distance.matrix<-distance.numeric
# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}
binary.test
#distance.matrix<-as.dist(distance.matrix)#
	dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
	dist2<-as.dist(2-(2* distance.matrix))#
	asymmetry.test<-any(c(dist1==dist2)==FALSE)#
	if(asymmetry.test){distance.matrix<-dist1#
	}else{distance.matrix<-dist2}
asymmetry.test
# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label
distance.matrix
attr(distance.matrix, "Labels")
str(distance.matrix)
attr(distance.matrix, "Size")
missing(attr(distance.matrix, "Labels"))
attr(distance.matrix, "Labels")==NULL
attr(distance.matrix, "Labels")==NA
length(attr(distance.matrix, "Labels"))
# if there are now row or column headings, add these now#
	if(length(attr(distance.matrix, "Labels"))==0){#
		attr(distance.matrix, "Labels")<-c(1:attr(distance.matrix, "Size"))}
distance.matrix
# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label
# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)
# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 1:7){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}
plot.defaults
binary.test
)#
	{#
# determine properties of input #
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
	dist2<-as.dist(2-(2* distance.matrix))#
	asymmetry.test<-any(c(dist1==dist2)==FALSE)#
	if(asymmetry.test){distance.matrix<-dist1#
	}else{distance.matrix<-dist2}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# if there are now row or column headings, add these now#
	if(length(attr(distance.matrix, "Labels"))==0){#
		attr(distance.matrix, "Labels")<-c(1:attr(distance.matrix, "Size"))}#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label
# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
	dist2<-as.dist(2-(2* distance.matrix))#
	asymmetry.test<-any(c(dist1==dist2)==FALSE)#
	if(asymmetry.test){distance.matrix<-dist1#
	}else{distance.matrix<-dist2}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# if there are now row or column headings, add these now#
	if(length(attr(distance.matrix, "Labels"))==0){#
		attr(distance.matrix, "Labels")<-c(1:attr(distance.matrix, "Size"))}#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label
point.defaults
binary.test
if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}
cut.vals
# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)
plot.defaults
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
	dist2<-as.dist(2-(2* distance.matrix))#
	asymmetry.test<-any(c(dist1==dist2)==FALSE)#
	if(asymmetry.test){distance.matrix<-dist1#
	}else{distance.matrix<-dist2}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# if there are now row or column headings, add these now#
	if(length(attr(distance.matrix, "Labels"))==0){#
		attr(distance.matrix, "Labels")<-c(1:attr(distance.matrix, "Size"))}#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 1:7){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function
plot.control<-check.plot.control(distance.numeric)
plot.control
result<-prep.numeric(distance.numeric, plot.control$points)
result
numeric.matrix<-distance.numeric
point.names<-attr(numeric.matrix, "Labels")
circle.points<-as.data.frame(make.circle(attr(numeric.matrix, "Size"))[, 2:3])
plot.defaults
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
	input<-distance.matrix#
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
	dist2<-as.dist(2-(2* distance.matrix))#
	asymmetry.test<-any(c(dist1==dist2)==FALSE)#
	if(asymmetry.test){distance.matrix<-dist1#
	}else{distance.matrix<-dist2}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# if there are now row or column headings, add these now#
	if(length(attr(distance.matrix, "Labels"))==0){#
		attr(distance.matrix, "Labels")<-c(1:attr(distance.matrix, "Size"))}#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		input.matrix<-input,#
		processed.matrix<-distance.matrix,#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 4:9){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function
distance.numeric
plot.control<-check.plot.control(distance.numeric)
plot.control
plot.control<-check.plot.control(distance.numeric)
plot.control
test.dist
circleplot(test.dist, plot.control=list(#
	line.breaks=c(-10, -1, -0.5, 0, 0.5, 1, 10),#
	line.cols=brewer.pal(6, "RdBu"),#
	line.curvature=0,#
	line.width=c(0.5, 2)))
dist1<-as.dist(as.matrix(distance.matrix))
dist1
dist2<-as.dist(t(as.matrix(distance.matrix))
dist2
dist2<-as.dist(t(as.matrix(distance.matrix)))
dist2
dist1==dist2
distance.numeric
distance.matrix<-distance.numeric
dist1<-as.dist(as.matrix(distance.matrix))#
		dist2<-as.dist(t(as.matrix(distance.matrix)))
dist1==dist2
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
	input<-distance.matrix#
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	if(binary.test){#
		dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
		dist2<-as.dist(2-(2* distance.matrix))#
		asymmetry.test<-any(c(dist1==dist2)==FALSE)#
		if(asymmetry.test){distance.matrix<-dist1#
		}else{distance.matrix<-dist2}#
	}else{#
		dist1<-as.dist(as.matrix(distance.matrix))#
		dist2<-as.dist(t(as.matrix(distance.matrix)))#
		asymmetry.test<-any(c(dist1==dist2)==FALSE)#
		if(asymmetry.test){distance.matrix<-mean(dist1, dist2)#
		}else{distance.matrix<-dist1}#
		}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# if there are now row or column headings, add these now#
	if(length(attr(distance.matrix, "Labels"))==0){#
		attr(distance.matrix, "Labels")<-c(1:attr(distance.matrix, "Size"))}#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		input.matrix=input,#
		processed.matrix=distance.matrix,#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 4:9){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function
plot.control<-check.plot.control(distance.numeric)
distance.numeric
distance.matrix
input<-distance.matrix
y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function#
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
	input<-distance.matrix#
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}
# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}
binary.test
# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	if(binary.test){#
		dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
		dist2<-as.dist(2-(2* distance.matrix))#
		asymmetry.test<-any(c(dist1==dist2)==FALSE)#
		if(asymmetry.test){distance.matrix<-dist1#
		}else{distance.matrix<-dist2}#
	}else{#
		dist1<-as.dist(as.matrix(distance.matrix))#
		dist2<-as.dist(t(as.matrix(distance.matrix)))#
		asymmetry.test<-any(c(dist1==dist2)==FALSE)#
		if(asymmetry.test){distance.matrix<-mean(dist1, dist2)#
		}else{distance.matrix<-dist1}#
		}
binary.test
dist1<-as.dist(as.matrix(distance.matrix))#
		dist2<-as.dist(t(as.matrix(distance.matrix)))#
		asymmetry.test<-any(c(dist1==dist2)==FALSE)
asymmetry.test
dist1
dist2
mean(dist1, dist2)
as.vector(dist1)
mean(as.vector(dist1), as.vector(dist2))
cbind(as.vector(dist1), as.vector(dist2))
apply(cbind(as.vector(dist1), as.vector(dist2)), 1, mean)
as.dist(apply(cbind(as.vector(dist1), as.vector(dist2)), 1, mean))
distance.matrix
str(dist1)
dist1dist1[1:55]
dist1[1:55]
length(dist1)
dist1
dist1[1:length(dist1)]<-apply(cbind(as.vector(dist1), as.vector(dist2)), 1, mean)
dist1
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
	input<-distance.matrix#
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	if(binary.test){#
		dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
		dist2<-as.dist(2-(2* distance.matrix))#
		asymmetry.test<-any(c(dist1==dist2)==FALSE)#
		if(asymmetry.test){distance.matrix<-dist1#
		}else{distance.matrix<-dist2}#
	}else{#
		dist1<-as.dist(as.matrix(distance.matrix))#
		dist2<-as.dist(t(as.matrix(distance.matrix)))#
		asymmetry.test<-any(c(dist1==dist2)==FALSE)#
		if(asymmetry.test){#
			dist1[1:length(dist1)]<-apply(cbind(as.vector(dist1), as.vector(dist2)), 1, mean)}#
		distance.matrix<-dist1#
		}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# if there are now row or column headings, add these now#
	if(length(attr(distance.matrix, "Labels"))==0){#
		attr(distance.matrix, "Labels")<-c(1:attr(distance.matrix, "Size"))}#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		input.matrix=input,#
		processed.matrix=distance.matrix,#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 4:9){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function
plot.control<-check.plot.control(distance.numeric)
plot.control
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "steelblue"),#
	line.width=2#
	))
distance.matrix
test.points<-matrix(data=rnorm(22), nrow=11, ncol=2)#
test.dist<-as.dist(scale(dist(test.points)))#
#
# make binary matrix from this continuous matrix, for example purposes only#
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, 0, 20), labels=FALSE)-1#
#
# directional binary matrix#
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)#
for(i in 1:dim(distance.matrix)[1]){distance.matrix[i, i]<-NA}#
#
# plot binary directional matrix#
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "steelblue"),#
	line.width=2#
	))
circleplot(test.dist2, plot.control=list(line.curvature=0, line.width=1))
# lines set a gradient in point colours#
circleplot(test.dist2, plot.control=list(#
	points=point.attributes,#
	line.gradient=TRUE,#
	line.curvature=0.6,#
	line.width=3))
# without curvature#
circleplot(test.dist, plot.control=list(#
	line.breaks=c(-10, -1, -0.5, 0, 0.5, 1, 10),#
	line.cols=brewer.pal(6, "RdBu"),#
	line.curvature=0,#
	line.width=c(0.5, 2)))
# a continuous plot with curvature#
circleplot(test.dist, plot.control=list(#
	points=point.attributes,#
	line.breaks=c(-10, -1, -0.5, 0, 0.5, 1, 10),#
	line.cols=brewer.pal(6, "RdBu"),#
	line.curvature=0.8,#
	line.width=c(1, 5)))
distance.matrix
plot.control<-check.plot.control(distance.matrix, plot.control)
plot.control
# trigonometric functions for circleplot#
#
# make a circle of specified size#
make.circle<-function(#
	n,	# number of points, equally spaced around the edge of a circle#
	alpha,	# offset angle, in radians#
	k)	# scaling value - larger for bigger circles. defaults to 1#
	{#
	if(missing(k))k<-1#
	if(missing(alpha))alpha<-0.4#
	# create output dataframe#
	values<-as.data.frame(matrix(data=NA, nrow=n, ncol=3))#
		colnames(values)<-c("theta", "x", "y")#
	for(i in 1:n)	# run loop to calculate all points#
		{#
		values$theta[i]<-(2*(pi/n)*seq(0, (n-1))[i])-alpha#
		values$x[i]<-k*cos(values$theta[i])#
		values$y[i]<-k*sin(values$theta[i])#
		}#
	return(values)#
	}#
# calculate the attributes of a triangle linking two points on the circumference and a point bisecting them, #
	# pc.scale gives the proportion of the distance between the base line and the origin#
# line linking the two points is taken to be horizontal#
triangle.coords<-function(coords, pc.scale=0.5)#
	{#
	radius<-sqrt(coords$x[1]**2 + coords$y[1]**2)#
	base.length<-sqrt((coords$x[1]-coords$x[2])**2 + (coords$y[1]-coords$y[2])**2)#
	adj<-base.length/2#
	adj.on.radius<-adj/radius#
	if(adj.on.radius<1){#
		angle1<-acos(adj.on.radius)#
		opp<-tan(angle1)*adj*pc.scale#
	}else{opp<-0}#
	coords.adjusted<-data.frame(x=c(-adj, 0, adj), y=c(0, opp, 0))#
	return(coords.adjusted)#
	}#
# find the apex of the curve linking coords (i.e. triangle1(points)[2, ])#
curve.apex<-function(coords, pc.scale=0.5)#
	{#
	mean.point<-c(x=mean(coords$x), y=mean(coords$y))#
	angle2<-atan(mean.point[2]/mean.point[1])	# angle between 0,0 and mean.point#
	#	angle2*(180/pi)#
	hyp<-sqrt(mean.point[1]^2+ mean.point[2]^2)*pc.scale#
	adj<-as.numeric(hyp*cos(angle2))#
	opp<-as.numeric(hyp*sin(angle2))#
	result<-data.frame(#
		x=c(mean.point[1], as.numeric(mean.point[1]-(adj*sign(mean.point[1])))), #
		y=c(mean.point[2], as.numeric(mean.point[2]-(opp*sign(mean.point[1])))))#
		# note: *sign() necessary to avoid -ve x vals giving apex(s) that are outside of the cirlce#
	rownames(result)<-c("mean", "apex")#
	output<-list(as.numeric(angle2), result)#
		names(output)<-c("angle", "coordinates")#
	return(output)#
	}#
# find a circle that matches points given by triangle.coords() - NOT IMPLEMENTED#
fit.circle<-function(coords){#
	y.diff<-((coords$x[1]^2)-(coords$y[2]^2))/(2*coords$y[2])#
	radius<-y.diff+coords$y[2]#
	x.vals<-seq(min(coords$x), max(coords$x), length.out=101)	# make an odd number for rotation#
	y.vals<-sqrt((radius^2)-(x.vals^2))#
	y.vals<-y.vals-y.vals[1]#
	curve.coordinates<-data.frame(x=x.vals, y=y.vals)#
	return(curve.coordinates)#
	}#
# fit a quadratic function to points given by triangle.coords()#
fit.quadratic<-function(coords)#
	{#
	model<-lm(y~x+I(x**2), data=coords)#
	newdata<-data.frame(x=seq(min(coords$x), max(coords$x), length.out=101))#
	newdata$y<-as.numeric(predict(model, newdata, se.fit=FALSE))#
	return(newdata)#
	}#
# take curved line give by fit.quadratic(), and rotate to the angle given by curve.apex()#
reposition.curve<-function(#
	curve,	# data.frame returned by fit.circle#
	apex		# list returned by curve.apex#
	)#
	{#
	adjusted.angle<-apex$angle-(90*pi/180)	# becuase your curve faces down, not right#
	# if(apex$coordinates$x[2]>0){adjusted.angle<-adjusted.angle+(pi/180)}#
	curve$y<-curve$y-curve$y[51]	# set apex =0,0#
	if(apex$coordinates$x[2]<0){#
		x.new<-(curve$x*cos(adjusted.angle))-(curve$y*sin(adjusted.angle))	# calculate transformation#
		y.new<-(curve$x*sin(adjusted.angle))+(curve$y*cos(adjusted.angle))#
	}else{#
		x.new<-(curve$x*cos(adjusted.angle))+(curve$y*sin(adjusted.angle))	# calculate transformation#
		y.new<-(curve$x*sin(adjusted.angle))-(curve$y*cos(adjusted.angle))#
	}#
	curve.new<-data.frame(x=x.new, y=y.new)		# put in new dataframe#
	curve.new$x<-curve.new$x+apex$coordinates$x[2]	# position to new x,y#
	curve.new$y<-curve.new$y+apex$coordinates$y[2]	#
	return(curve.new)#
	}
# Set of functions to prepare input objects for plotting. Returns a set of usable point and line attributes.#
#
# internal function for arranging points for plotting binary matrices. This does all of the work in the current version.#
inner.circle<-function(#
	dataset,#
	point.attributes,#
	simple#
	)#
	{#
	# set behaviour for included points#
	if(simple){min.value<-0}else{min.value<-1}#
#
	# subset to only points >min mentions (over both rows and cols - important for asymmetric matrices)#
	keep.rows<-as.numeric(which(apply(dataset, 1, FUN=function(x){sum(x, na.rm=TRUE)})>min.value))#
	keep.cols<-as.numeric(which(apply(dataset, 2, FUN=function(x){sum(x, na.rm=TRUE)})>min.value))	#
	keep.units<-sort(unique(c(keep.rows, keep.cols)))#
	dataset<-dataset[keep.rows, keep.rows]#
#
	# make a distance matrix that functions for both symmetric and asymmetric matrices#
	dataset.dist<-as.dist(2-(dataset+t(dataset))) # t() stage important for asymmetric matrices#
	data.names<-attr(dataset.dist, "Labels")#
#
	# if point attributes are set by default, these will be too large; reduce to appropriate size#
	if(dim(point.attributes)[1]>dim(dataset)[1]){#
		point.attributes<-merge(point.attributes, #
			data.frame(label= data.names, stringsAsFactors=FALSE),#
			by="label", all=FALSE)#
		rownames(point.attributes)<-point.attributes$label#
		}#
#
	# make points for plotting#
	# circle.points<-circle.point.arrangement(dataset)#
	circle.points<-as.data.frame(make.circle(attr(dataset.dist, "Size"))[, 2:3])#
	cluster.result<-hclust(dataset.dist)#
	circle.points$label<-attr(dataset.dist, "Labels")[cluster.result$order]#
		circle.points$label<-as.character(circle.points$label)#
	circle.points<-circle.points[order(circle.points$label), ]#
#
	# now make line dataset to allow drawing of lines#
	# point.connections<-as.dist(dataset) # replaced with dataset.dist#
	# point.names<-attr(point.connections, "Labels")#
	line.list<-as.data.frame(cbind(t(combn(data.names, 2)), as.numeric(dataset.dist)))#
		colnames(line.list)<-c("sp1", "sp2", "value")#
		for(i in 1:2){line.list[, i]<-as.character(line.list[, i])}#
	line.list$value<-2-as.numeric(as.character(line.list$value))		# how many connections#
#
	# determine the direction of these connections#
	direction.matrix<-as.dist(dataset)-as.dist(t(dataset))#
	direction.matrix[which(direction.matrix==0)]<-1#
	line.list$value<-line.list$value*as.numeric(direction.matrix)#
#
	# remove 'absent' connections#
	line.list<-line.list[-which(line.list$value==0), ]#
#
	# add attributes to circle locations#
	circle.points<-merge(circle.points, point.attributes, by="label")#
		circle.points<-circle.points[, c(2, 3, 1, 4, 5)]#
		rownames(circle.points)<-circle.points$label#
#
	# export#
	return(list(points=circle.points, lines=line.list))#
	}#
# anouther function for plotting binary matrices - NOT IMPLEMENTED YET#
# this will be used to add 'singletons' to an outer edge of points in circleplot().#
outer.circle<-function(#
	dataset,	# simple conversion from an adjavency matrix#
	initial.points	# result from inner.circle()#
	)#
	{#
	excluded.rows<-as.numeric(which(apply(dataset, 1, sum)==1))#
	n.points<-length(excluded.rows)#
#
	# look at excluded information - i.e. those with only one connection#
	cols.thisrun<-apply(dataset[excluded.rows, ], 1, function(x){which(x>0)})#
	single.connections<-data.frame(#
		initial=colnames(dataset)[cols.thisrun],#
		final=names(cols.thisrun), stringsAsFactors=FALSE)#
#
	# convert this to a frequency table#
	reduced.points<-xtabs(rep(1, dim(single.connections)[1])~ single.connections$initial)#
	reduced.points<-data.frame(#
		label=names(reduced.points),#
		freq=as.numeric(reduced.points))#
	reduced.points<-reduced.points[order(reduced.points$freq, decreasing=TRUE), ]#
#
	# work out how large the new circle needs to be not to look out of place#
	interpoint.dist<-min(dist(initial.points$points[, 1:2]))#
	n.total<-ceiling((pi*3)/interpoint.dist)#
	if(n.total>n.points){final.n<-n.total}else{final.n<-n.points}#
	circle2<-make.circle(n.total, k=1.5)[, 2:3]#
		circle2$label.inital<-rep("none", dim(circle2)[1])#
		circle2$label.final<-rep("none", dim(circle2)[1])#
		circle2$allocated<-rep(0, dim(circle2)[1])#
#
	# determine which points in circle2 should be assigned to each final point#
	for(i in 1:dim(reduced.points)[1])#
		{#
		initial.thisrun<-which(initial.points$points$label==reduced.points$label[i])#
		values<-initial.points$points[initial.thisrun, ]#
		# work out which (remaining) points are closest#
		point.distances<-rep(NA, final.n)#
		for(j in 1:length(point.distances)){#
			point.distances[j]<-sqrt((circle2$x[j]-values$x)^2 + (circle2$y[j]-values$y)^2)}#
		points.thisrun<-order(point.distances[which(circle2$allocated==0)], #
			decreasing=TRUE)[1: reduced.points$freq[i]]#
#
		# export this information#
		circle2$allocated[points.thisrun]<-1#
		circle2$label.inital[points.thisrun]<-values$label#
		circle2$label.final[points.thisrun]<-single.connections$final[which(single.connections$initial==values$label)]#
		}	#end i#
#
	# remove irrelevant rows/columns from circle2#
	circle2<-circle2[which(circle2$allocated==1), 1:4]#
	return(list(points=circle2, frequencies= reduced.points))#
	}#
# get binary data into an appropriate format for plotting#
# this is called by plot.curves() via draw.circle(), and uses draw.curves() to actually add the segments. #
prep.binary<-function(#
	adjacency.matrix, #
	point.attributes,#
	simple	# should this be a simple (1 circle) or complex (2 circles) plot? 2 circle version incomplete#
	)#
	{#
	if(missing(simple))simple<-TRUE#
	# take adjacency matrix, identify groups with many connections#
	dataset<-as.matrix(adjacency.matrix)#
	# apply(dataset, 1, sum)==apply(dataset, 2, sum) # can use row or col sums#
#
	# calculate points/lines#
	result<-inner.circle(dataset, point.attributes, simple)#
	if(simple==FALSE){#
		added.points<-outer.circle(dataset, initial.points)#
		result$outer.circle=added.points$points#
		result$outer.freq=added.points$freq#
		}#
#
	return(result)#
	}	# end function#
# function to prepare data for analysis if input matrix is numeric#
prep.numeric<-function(#
	numeric.matrix, #
	point.attributes#
	)#
	{#
	point.names<-attr(numeric.matrix, "Labels")	#
#
	# point info prep (Note: could add a clustering algorithm here to better represent inter-point relationships)#
	circle.points<-as.data.frame(make.circle(attr(numeric.matrix, "Size"))[, 2:3])#
	# work out point order using clustering#
	connection.distance<-as.dist(1-(sqrt(numeric.matrix^2)))#
	result<-hclust(connection.distance)#
	circle.points$label<-point.names[result$order]#
#
	# add point attributes#
	circle.points<-merge(circle.points, point.attributes, by="label")#
		circle.points<-circle.points[, c(2, 3, 1, 4, 5)]#
		rownames(circle.points)<-circle.points$label#
#
	# line info prep#
	line.list<-as.data.frame(cbind(t(combn(point.names, 2)), as.vector(numeric.matrix)), #
		stringsAsFactors=FALSE)#
	colnames(line.list)<-c("sp1", "sp2", "value")#
	line.list$value<-as.numeric(line.list$value)#
#
	# order line list by effect size#
	effect.size<-line.list$value^2#
	line.list<-line.list[order(effect.size), ]#
#
	return(list(points=circle.points, lines=line.list))#
	}
# plot functions#
#
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=50)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				colours.final<-c(rep(colours.final[1], 50), colours.final)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				# reverse if order is wrong#
				if(result$lines$value[i]==-1){colours.final<-colours.final[100:1]}		#
				if(result$lines$value[i]==2){colours.final<-rep(plot.control$line.cols[2], 100)}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}		#
#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function#
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
	input<-distance.matrix#
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	if(binary.test){#
		dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
		dist2<-as.dist(2-(2* distance.matrix))#
		asymmetry.test<-any(c(dist1==dist2)==FALSE)#
		if(asymmetry.test){distance.matrix<-dist1#
		}else{distance.matrix<-dist2}#
	}else{#
		dist1<-as.dist(as.matrix(distance.matrix))#
		dist2<-as.dist(t(as.matrix(distance.matrix)))#
		asymmetry.test<-any(c(dist1==dist2)==FALSE)#
		if(asymmetry.test){#
			dist1[1:length(dist1)]<-apply(cbind(as.vector(dist1), as.vector(dist2)), 1, mean)}#
		distance.matrix<-dist1#
		}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# if there are now row or column headings, add these now#
	if(length(attr(distance.matrix, "Labels"))==0){#
		attr(distance.matrix, "Labels")<-c(1:attr(distance.matrix, "Size"))}#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		input.matrix=input,#
		processed.matrix=distance.matrix,#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 4:9){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function#
# function to use the above code to draw a figure#
circleplot<-function(#
	distance.matrix,	# i.e. a distance matrix (class 'dist') containing binary values#
	plot.control	# a matrix containing any or all of the following compenents:#
		# points = point.attributes, # if given, a data.frame with colnames=c('label', "colour", "size")#
		# lines 	#
			# .gradient - TRUE or FALSE - used to determine whether lines should display a colour gradient#
			# .breaks - vector used to determine the breaks for colours#
			# .colours - vector containing colours. used with 'breaks' above. length= length(breaks)-1#
			# .curvature - a percentage giving the % of maximum sent to gaussian curve#
				# i.e. curvature=1 always has a min=0, max=max, while curvature=0 is equivalent to linear#
				# (formerly line.emphasis - "gaussian" or "linear").#
			# .width = vector if length-1 contains absolute value; if length-2 contains minimum and max#
	# simple	# later, will be passed to prep.binary - whether to draw a complex plot (or not). defaults to TRUE.#
	)#
	{#
	# set plot attributes/defaults#
	plot.control<-check.plot.control(distance.matrix, plot.control)#
#
	# run appropriate prep code#
	if(plot.control$properties[1]){	# if binary#
		result<-prep.binary(distance.matrix, plot.control$points)#
	}else{#
		result<-prep.numeric(distance.matrix, plot.control$points)}#
#
	# call plot code#
	par(mar=rep(0.5, 4))	# set window attributes#
	plot(x= result$points$x, y= result$points$y, type="n", ann=FALSE, axes=FALSE, asp=1)	# plot#
	draw.curves(result, plot.control) #$points, line.list, line.widths, line.gradient)	# add lines#
	points(result$points$x, result$points$y, 	# add points#
		pch=19, #
		col= result$points$colour, #
		cex= result$points$size)#
	text(result$points$x, result$points$y, label= result$points$label, col="white", cex=0.7)	# label points#
#
	# if(singletons)add.outer.points#
	}#
# simple code to get pretty point colours#
point.attr<-function(distance.matrix)#
	{#
	#library(RColorBrewer)	# to choose an existing palette#
	labels<-as.character(attr(distance.matrix, "Labels"))#
	color.hex<-c(RColorBrewer::brewer.pal(8, "Dark2"), #
		brewer.pal(9, "Set1"),#
		brewer.pal(8, "Set2")#
		)[1:length(labels)]#
	point.attributes<-data.frame(#
			label= labels,#
			colour=color.hex,#
			size=rep(3, length(labels)),#
			stringsAsFactors=FALSE)#
	}
library(RColorBrewer)
test.points<-matrix(data=rnorm(22), nrow=11, ncol=2)#
test.dist<-as.dist(scale(dist(test.points)))#
#
# make binary matrix from this continuous matrix, for example purposes only#
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, 0, 20), labels=FALSE)-1#
#
# directional binary matrix#
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)#
for(i in 1:dim(distance.matrix)[1]){distance.matrix[i, i]<-NA}
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "steelblue"),#
	line.width=2#
	))
plot.control<-check.plot.control(distance.matrix)#, plot.control)
distance.matrix
plot.control
result<-prep.binary(distance.matrix, plot.control$points)
par(mar=rep(0.5, 4))	# set window attributes#
	plot(x= result$points$x, y= result$points$y, type="n", ann=FALSE, axes=FALSE, asp=1)	# plot#
	draw.curves(result, plot.control) #$points, line.list, line.widths, line.gradient)	# add lines#
	points(result$points$x, result$points$y, 	# add points#
		pch=19, #
		col= result$points$colour, #
		cex= result$points$size)#
	text(result$points$x, result$points$y, label= result$points$label, col="white", cex=0.7)	# label points
# plot binary directional matrix#
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "steelblue"),#
	line.width=2#
	))
# trigonometric functions for circleplot#
#
# make a circle of specified size#
make.circle<-function(#
	n,	# number of points, equally spaced around the edge of a circle#
	alpha,	# offset angle, in radians#
	k)	# scaling value - larger for bigger circles. defaults to 1#
	{#
	if(missing(k))k<-1#
	if(missing(alpha))alpha<-0.4#
	# create output dataframe#
	values<-as.data.frame(matrix(data=NA, nrow=n, ncol=3))#
		colnames(values)<-c("theta", "x", "y")#
	for(i in 1:n)	# run loop to calculate all points#
		{#
		values$theta[i]<-(2*(pi/n)*seq(0, (n-1))[i])-alpha#
		values$x[i]<-k*cos(values$theta[i])#
		values$y[i]<-k*sin(values$theta[i])#
		}#
	return(values)#
	}#
# calculate the attributes of a triangle linking two points on the circumference and a point bisecting them, #
	# pc.scale gives the proportion of the distance between the base line and the origin#
# line linking the two points is taken to be horizontal#
triangle.coords<-function(coords, pc.scale=0.5)#
	{#
	radius<-sqrt(coords$x[1]**2 + coords$y[1]**2)#
	base.length<-sqrt((coords$x[1]-coords$x[2])**2 + (coords$y[1]-coords$y[2])**2)#
	adj<-base.length/2#
	adj.on.radius<-adj/radius#
	if(adj.on.radius<1){#
		angle1<-acos(adj.on.radius)#
		opp<-tan(angle1)*adj*pc.scale#
	}else{opp<-0}#
	coords.adjusted<-data.frame(x=c(-adj, 0, adj), y=c(0, opp, 0))#
	return(coords.adjusted)#
	}#
# find the apex of the curve linking coords (i.e. triangle1(points)[2, ])#
curve.apex<-function(coords, pc.scale=0.5)#
	{#
	mean.point<-c(x=mean(coords$x), y=mean(coords$y))#
	angle2<-atan(mean.point[2]/mean.point[1])	# angle between 0,0 and mean.point#
	#	angle2*(180/pi)#
	hyp<-sqrt(mean.point[1]^2+ mean.point[2]^2)*pc.scale#
	adj<-as.numeric(hyp*cos(angle2))#
	opp<-as.numeric(hyp*sin(angle2))#
	result<-data.frame(#
		x=c(mean.point[1], as.numeric(mean.point[1]-(adj*sign(mean.point[1])))), #
		y=c(mean.point[2], as.numeric(mean.point[2]-(opp*sign(mean.point[1])))))#
		# note: *sign() necessary to avoid -ve x vals giving apex(s) that are outside of the cirlce#
	rownames(result)<-c("mean", "apex")#
	output<-list(as.numeric(angle2), result)#
		names(output)<-c("angle", "coordinates")#
	return(output)#
	}#
# find a circle that matches points given by triangle.coords() - NOT IMPLEMENTED#
fit.circle<-function(coords){#
	y.diff<-((coords$x[1]^2)-(coords$y[2]^2))/(2*coords$y[2])#
	radius<-y.diff+coords$y[2]#
	x.vals<-seq(min(coords$x), max(coords$x), length.out=101)	# make an odd number for rotation#
	y.vals<-sqrt((radius^2)-(x.vals^2))#
	y.vals<-y.vals-y.vals[1]#
	curve.coordinates<-data.frame(x=x.vals, y=y.vals)#
	return(curve.coordinates)#
	}#
# fit a quadratic function to points given by triangle.coords()#
fit.quadratic<-function(coords)#
	{#
	model<-lm(y~x+I(x**2), data=coords)#
	newdata<-data.frame(x=seq(min(coords$x), max(coords$x), length.out=101))#
	newdata$y<-as.numeric(predict(model, newdata, se.fit=FALSE))#
	return(newdata)#
	}#
# take curved line give by fit.quadratic(), and rotate to the angle given by curve.apex()#
reposition.curve<-function(#
	curve,	# data.frame returned by fit.circle#
	apex		# list returned by curve.apex#
	)#
	{#
	adjusted.angle<-apex$angle-(90*pi/180)	# becuase your curve faces down, not right#
	# if(apex$coordinates$x[2]>0){adjusted.angle<-adjusted.angle+(pi/180)}#
	curve$y<-curve$y-curve$y[51]	# set apex =0,0#
	if(apex$coordinates$x[2]<0){#
		x.new<-(curve$x*cos(adjusted.angle))-(curve$y*sin(adjusted.angle))	# calculate transformation#
		y.new<-(curve$x*sin(adjusted.angle))+(curve$y*cos(adjusted.angle))#
	}else{#
		x.new<-(curve$x*cos(adjusted.angle))+(curve$y*sin(adjusted.angle))	# calculate transformation#
		y.new<-(curve$x*sin(adjusted.angle))-(curve$y*cos(adjusted.angle))#
	}#
	curve.new<-data.frame(x=x.new, y=y.new)		# put in new dataframe#
	curve.new$x<-curve.new$x+apex$coordinates$x[2]	# position to new x,y#
	curve.new$y<-curve.new$y+apex$coordinates$y[2]	#
	return(curve.new)#
	}
# Set of functions to prepare input objects for plotting. Returns a set of usable point and line attributes.#
#
# internal function for arranging points for plotting binary matrices. This does all of the work in the current version.#
inner.circle<-function(#
	dataset,#
	point.attributes,#
	simple#
	)#
	{#
	# set behaviour for included points#
	if(simple){min.value<-0}else{min.value<-1}#
#
	# subset to only points >min mentions (over both rows and cols - important for asymmetric matrices)#
	keep.rows<-as.numeric(which(apply(dataset, 1, FUN=function(x){sum(x, na.rm=TRUE)})>min.value))#
	keep.cols<-as.numeric(which(apply(dataset, 2, FUN=function(x){sum(x, na.rm=TRUE)})>min.value))	#
	keep.units<-sort(unique(c(keep.rows, keep.cols)))#
	dataset<-dataset[keep.rows, keep.rows]#
#
	# make a distance matrix that functions for both symmetric and asymmetric matrices#
	dataset.dist<-as.dist(2-(dataset+t(dataset))) # t() stage important for asymmetric matrices#
	data.names<-attr(dataset.dist, "Labels")#
#
	# if point attributes are set by default, these will be too large; reduce to appropriate size#
	if(dim(point.attributes)[1]>dim(dataset)[1]){#
		point.attributes<-merge(point.attributes, #
			data.frame(label= data.names, stringsAsFactors=FALSE),#
			by="label", all=FALSE)#
		rownames(point.attributes)<-point.attributes$label#
		}#
#
	# make points for plotting#
	# circle.points<-circle.point.arrangement(dataset)#
	circle.points<-as.data.frame(make.circle(attr(dataset.dist, "Size"))[, 2:3])#
	cluster.result<-hclust(dataset.dist)#
	circle.points$label<-attr(dataset.dist, "Labels")[cluster.result$order]#
		circle.points$label<-as.character(circle.points$label)#
	circle.points<-circle.points[order(circle.points$label), ]#
#
	# now make line dataset to allow drawing of lines#
	# point.connections<-as.dist(dataset) # replaced with dataset.dist#
	# point.names<-attr(point.connections, "Labels")#
	line.list<-as.data.frame(cbind(t(combn(data.names, 2)), as.numeric(dataset.dist)))#
		colnames(line.list)<-c("sp1", "sp2", "value")#
		for(i in 1:2){line.list[, i]<-as.character(line.list[, i])}#
	line.list$value<-2-as.numeric(as.character(line.list$value))		# how many connections#
#
	# determine the direction of these connections#
	direction.matrix<-as.dist(dataset)-as.dist(t(dataset))#
	direction.matrix[which(direction.matrix==0)]<-1#
	line.list$value<-line.list$value*as.numeric(direction.matrix)#
#
	# remove 'absent' connections#
	line.list<-line.list[-which(line.list$value==0), ]#
#
	# add attributes to circle locations#
	circle.points<-merge(circle.points, point.attributes, by="label")#
		circle.points<-circle.points[, c(2, 3, 1, 4, 5)]#
		rownames(circle.points)<-circle.points$label#
#
	# export#
	return(list(points=circle.points, lines=line.list))#
	}#
# anouther function for plotting binary matrices - NOT IMPLEMENTED YET#
# this will be used to add 'singletons' to an outer edge of points in circleplot().#
outer.circle<-function(#
	dataset,	# simple conversion from an adjavency matrix#
	initial.points	# result from inner.circle()#
	)#
	{#
	excluded.rows<-as.numeric(which(apply(dataset, 1, sum)==1))#
	n.points<-length(excluded.rows)#
#
	# look at excluded information - i.e. those with only one connection#
	cols.thisrun<-apply(dataset[excluded.rows, ], 1, function(x){which(x>0)})#
	single.connections<-data.frame(#
		initial=colnames(dataset)[cols.thisrun],#
		final=names(cols.thisrun), stringsAsFactors=FALSE)#
#
	# convert this to a frequency table#
	reduced.points<-xtabs(rep(1, dim(single.connections)[1])~ single.connections$initial)#
	reduced.points<-data.frame(#
		label=names(reduced.points),#
		freq=as.numeric(reduced.points))#
	reduced.points<-reduced.points[order(reduced.points$freq, decreasing=TRUE), ]#
#
	# work out how large the new circle needs to be not to look out of place#
	interpoint.dist<-min(dist(initial.points$points[, 1:2]))#
	n.total<-ceiling((pi*3)/interpoint.dist)#
	if(n.total>n.points){final.n<-n.total}else{final.n<-n.points}#
	circle2<-make.circle(n.total, k=1.5)[, 2:3]#
		circle2$label.inital<-rep("none", dim(circle2)[1])#
		circle2$label.final<-rep("none", dim(circle2)[1])#
		circle2$allocated<-rep(0, dim(circle2)[1])#
#
	# determine which points in circle2 should be assigned to each final point#
	for(i in 1:dim(reduced.points)[1])#
		{#
		initial.thisrun<-which(initial.points$points$label==reduced.points$label[i])#
		values<-initial.points$points[initial.thisrun, ]#
		# work out which (remaining) points are closest#
		point.distances<-rep(NA, final.n)#
		for(j in 1:length(point.distances)){#
			point.distances[j]<-sqrt((circle2$x[j]-values$x)^2 + (circle2$y[j]-values$y)^2)}#
		points.thisrun<-order(point.distances[which(circle2$allocated==0)], #
			decreasing=TRUE)[1: reduced.points$freq[i]]#
#
		# export this information#
		circle2$allocated[points.thisrun]<-1#
		circle2$label.inital[points.thisrun]<-values$label#
		circle2$label.final[points.thisrun]<-single.connections$final[which(single.connections$initial==values$label)]#
		}	#end i#
#
	# remove irrelevant rows/columns from circle2#
	circle2<-circle2[which(circle2$allocated==1), 1:4]#
	return(list(points=circle2, frequencies= reduced.points))#
	}#
# get binary data into an appropriate format for plotting#
# this is called by plot.curves() via draw.circle(), and uses draw.curves() to actually add the segments. #
prep.binary<-function(#
	adjacency.matrix, #
	point.attributes,#
	simple	# should this be a simple (1 circle) or complex (2 circles) plot? 2 circle version incomplete#
	)#
	{#
	if(missing(simple))simple<-TRUE#
	# take adjacency matrix, identify groups with many connections#
	dataset<-as.matrix(adjacency.matrix)#
	# apply(dataset, 1, sum)==apply(dataset, 2, sum) # can use row or col sums#
#
	# calculate points/lines#
	result<-inner.circle(dataset, point.attributes, simple)#
	if(simple==FALSE){#
		added.points<-outer.circle(dataset, initial.points)#
		result$outer.circle=added.points$points#
		result$outer.freq=added.points$freq#
		}#
#
	return(result)#
	}	# end function#
# function to prepare data for analysis if input matrix is numeric#
prep.numeric<-function(#
	numeric.matrix, #
	point.attributes#
	)#
	{#
	point.names<-attr(numeric.matrix, "Labels")	#
#
	# point info prep (Note: could add a clustering algorithm here to better represent inter-point relationships)#
	circle.points<-as.data.frame(make.circle(attr(numeric.matrix, "Size"))[, 2:3])#
	# work out point order using clustering#
	connection.distance<-as.dist(1-(sqrt(numeric.matrix^2)))#
	result<-hclust(connection.distance)#
	circle.points$label<-point.names[result$order]#
#
	# add point attributes#
	circle.points<-merge(circle.points, point.attributes, by="label")#
		circle.points<-circle.points[, c(2, 3, 1, 4, 5)]#
		rownames(circle.points)<-circle.points$label#
#
	# line info prep#
	line.list<-as.data.frame(cbind(t(combn(point.names, 2)), as.vector(numeric.matrix)), #
		stringsAsFactors=FALSE)#
	colnames(line.list)<-c("sp1", "sp2", "value")#
	line.list$value<-as.numeric(line.list$value)#
#
	# order line list by effect size#
	effect.size<-line.list$value^2#
	line.list<-line.list[order(effect.size), ]#
#
	return(list(points=circle.points, lines=line.list))#
	}
# plot functions#
#
# add curved connecting lines to circleplot()#
draw.curves<-function(#
	input,#
	plot.control#
	)#
	{#
	# calculate inter-point distances, to allow setting of pc.scale (to calculate curvature of lines relative to origin)#
	point.distance<-dist(input$points[, 1:2])#
	scale.distance<-point.distance-min(point.distance)#
		multiplier<-0.35; add<-0.25#
	scale.distance<-((scale.distance/max(scale.distance))*multiplier)+add#
	scale.distance<-as.matrix(scale.distance)#
#
	# set line colours. Note that this works even for binary matrices, but is later ignored if line.gradient==FALSE#
	line.cuts<-cut(input$lines$value, plot.control$line.breaks, include.lowest=TRUE, labels=FALSE)#
	input$lines$colour<-plot.control$line.cols[line.cuts]#
#
	# add min and max widths per line#
	if(plot.control$properties[1]){	# binary#
		if(length(plot.control$line.width)==2){plot.control$line.width<-plot.control$line.width[2]}} # fix if too many vals#
	if(length(plot.control$line.width)==1){	# for a single value, make the line width a maximum value#
		input$lines$lwd.min<-plot.control$line.width-(plot.control$line.width*plot.control$line.curvature)#
		input$lines$lwd.max<-plot.control$line.width#
	}else{	# otherwise, set range#
		data.thisrun<-input$lines$value	# export data on the value of each line#
		specified.range<-max(plot.control$line.width)-min(plot.control$line.width)	# range of desired values#
		data.thisrun<-data.thisrun-min(data.thisrun)	# scale data.this run to this same range#
		data.thisrun<-(data.thisrun/max(data.thisrun))*specified.range#
		input$lines$lwd.min<-data.thisrun-(data.thisrun*plot.control$line.curvature)+min(plot.control$line.width)#
		input$lines$lwd.max<-data.thisrun+min(plot.control$line.width)#
		}#
#
	# set default line widths (0-1 range)#
	x<-seq(-2, 2, length.out=100)#
	line.widths<-dnorm(x, mean=0, sd=0.5)#
	line.widths<-line.widths-min(line.widths); line.widths<-line.widths/max(line.widths)#
#
	# loop to draw lines of requisite location and colour#
	for(i in 1:dim(input$lines)[1])	#
		{#
		# sort out coords for this row#
		row1<-which(input$points$label==input$lines$sp1[i])#
		row2<-which(input$points$label==input$lines$sp2[i])#
		coords<-data.frame(x=input$points$x[c(row1, row2)],#
			y=input$points$y[c(row1, row2)])#
		# find basic spatial info on these points#
		distance.thisrun<-scale.distance[row1, row2]#
		coords.scaled<-triangle.coords(coords, distance.thisrun) # what coordinates should the curve be fit to?#
#
		# calculate the curve that fits between these points.#
		# Note that if there are an even number of points, some will pass through the intercept, causing code to fail#
		if(coords.scaled$y[2]>0.0001){#
			apex<-curve.apex(coords, distance.thisrun)#
			curve.coords<-fit.quadratic(coords.scaled)#
			new.curve<-reposition.curve(curve.coords, apex)#
		}else{	# i.e. if a straight line#
			new.curve<-data.frame(#
				x=seq(coords$x[1], coords$x[2], length.out=101), #
 				y=seq(coords$y[1], coords$y[2], length.out=101))#
		} #
#
		# set line widths#
		lwd.range<-input$lines$lwd.max[i]-input$lines$lwd.min[i]#
		line.widths.thisrun<-(line.widths*lwd.range)+input$lines$lwd.min[i]#
#
		# set line colours according to categorical or continuous lines 	#
		if(plot.control$properties[1]){	# binary#
#
			if(plot.control$properties[2]){ # asymmetric#
				color.matrix<-col2rgb(plot.control$line.cols)#
				color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=50)})#
				colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
				colours.final<-c(rep(colours.final[1], 50), colours.final)#
				# ensure colours are in correct order#
				distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
				if(distance.pos>0.001){colours.final<-colours.final[100:1]}#
				# reverse if order is wrong#
				if(result$lines$value[i]==-1){colours.final<-colours.final[100:1]}		#
				if(result$lines$value[i]==2){colours.final<-rep(plot.control$line.cols[2], 100)}#
#
			}else{	# symmetric#
#
				if(plot.control$line.gradient){		# lines coloured according to a gradient#
					# get line colours from input$points#
					color1<-input$points$colour[row1]#
					color2<-input$points$colour[row2]#
					color.matrix<-col2rgb(c(color1, color2))#
					color.matrix.expanded<-apply(color.matrix, 1, function(x){seq(x[1], x[2], length.out=100)})#
					colours.final<-rgb(color.matrix.expanded, maxColorValue=255)#
					# ensure colours are in correct order#
					distance.pos<-sqrt((new.curve$x[1]-input$points$x[row1])^2)#
					if(distance.pos>0.001){colours.final<-colours.final[100:1]}		#
#
				}else{#
					colours.final<-rep(input$lines$colour[i], 100)	# single colour#
#
				}}	# end if asymmetric#
		}else{	# if numeric#
			colours.final<-rep(input$lines$colour[i], 100)#
		}#
#
		# draw a line that smoothly changes between these colours#
		segments(#
			x0= new.curve$x[1:100], x1= new.curve$x[2:101],#
			y0= new.curve$y[1:100], y1= new.curve$y[2:101],#
			col= colours.final,#
			lwd= line.widths.thisrun)#
		}	# end loop#
	}	# end function#
# function to set plot properties#
check.plot.control<-function(#
	distance.matrix,#
	plot.control#
	)#
	{#
# determine properties of input #
	input<-distance.matrix#
#
	# work out if input is binary or continuous#
	binary.test<-c(max(distance.matrix, na.rm=TRUE)-min(distance.matrix, na.rm=TRUE)==1,	#
		max(distance.matrix, na.rm=TRUE)==1)#
	if(any(binary.test==FALSE)==FALSE){binary.test<-TRUE}else{binary.test<-FALSE}#
#
	# check whether the input matrix is symmetric or asymmetric#
	#distance.matrix<-as.dist(distance.matrix)#
	if(binary.test){#
		dist1<-as.dist(2-(distance.matrix +t(distance.matrix)))	#
		dist2<-as.dist(2-(2* distance.matrix))#
		asymmetry.test<-any(c(dist1==dist2)==FALSE)#
		if(asymmetry.test){distance.matrix<-dist1#
		}else{distance.matrix<-dist2}#
	}else{#
		dist1<-as.dist(as.matrix(distance.matrix))#
		dist2<-as.dist(t(as.matrix(distance.matrix)))#
		asymmetry.test<-any(c(dist1==dist2)==FALSE)#
		if(asymmetry.test){#
			dist1[1:length(dist1)]<-apply(cbind(as.vector(dist1), as.vector(dist2)), 1, mean)}#
		distance.matrix<-dist1#
		}#
#
	# export these#
	matrix.properties<-c(#
		#class=class(distance.matrix), #
		binary=binary.test,#
		asymmetric= asymmetry.test)#
#
	# if there are now row or column headings, add these now#
	if(length(attr(distance.matrix, "Labels"))==0){#
		attr(distance.matrix, "Labels")<-c(1:attr(distance.matrix, "Size"))}#
#
	# generate a some default values for points#
	point.defaults<-data.frame(#
			label=attr(distance.matrix, "Labels"),#
			colour=rep(rgb(t(col2rgb("grey30")), maxColorValue=255), attr(distance.matrix, "Size")),#
			size=rep(2, attr(distance.matrix, "Size")),#
			stringsAsFactors=FALSE)#
	rownames(point.defaults)<-point.defaults$label#
#
	# generate sensible cuts for line colours#
	if(binary.test){cut.vals<-c(-1, 2)#
	}else{cut.vals<-c(min(distance.matrix, na.rm=TRUE), max(distance.matrix, na.rm=TRUE))}#
#
	# make a list of point and line attributes, showing the required properties#
	plot.defaults<-list(#
		input.matrix=input,#
		processed.matrix=distance.matrix,#
		properties=matrix.properties,#
		points=point.defaults,#
		line.gradient=FALSE,	# option for binary matrices only#
		line.breaks=cut.vals,#
		line.cols="grey30",#
		line.curvature=0.3,#
		line.width=1#
		)#
	# overwrite these values where others are provided#
	if(missing(plot.control)==FALSE){#
		names.provided<-names(plot.control)#
		for(i in 4:9){#
			if(any(names.provided==names(plot.defaults)[i])){#
			entry.thisrun<-which(names.provided==names(plot.defaults)[i])#
			plot.defaults[[i]]<-plot.control[[entry.thisrun]]#
			}}}#
#
	# make up to two colours if asymmetry.test==TRUE, and two points have not yet been provided#
	default.directional.cols<-c("grey80", "grey10")#
	if(asymmetry.test){#
		if(length(plot.defaults$line.cols)==1){#
			if(plot.defaults$line.cols=="grey30"){plot.defaults$line.cols<-default.directional.cols#
			}else{plot.defaults$line.cols<-c(default.directional.cols[1], plot.defaults$line.cols)}}}#
#
	return(plot.defaults)#
	}	# end function#
# function to use the above code to draw a figure#
circleplot<-function(#
	distance.matrix,	# i.e. a distance matrix (class 'dist') containing binary values#
	plot.control	# a matrix containing any or all of the following compenents:#
		# points = point.attributes, # if given, a data.frame with colnames=c('label', "colour", "size")#
		# lines 	#
			# .gradient - TRUE or FALSE - used to determine whether lines should display a colour gradient#
			# .breaks - vector used to determine the breaks for colours#
			# .colours - vector containing colours. used with 'breaks' above. length= length(breaks)-1#
			# .curvature - a percentage giving the % of maximum sent to gaussian curve#
				# i.e. curvature=1 always has a min=0, max=max, while curvature=0 is equivalent to linear#
				# (formerly line.emphasis - "gaussian" or "linear").#
			# .width = vector if length-1 contains absolute value; if length-2 contains minimum and max#
	# simple	# later, will be passed to prep.binary - whether to draw a complex plot (or not). defaults to TRUE.#
	)#
	{#
	# set plot attributes/defaults#
	plot.control<-check.plot.control(distance.matrix, plot.control)#
#
	# run appropriate prep code#
	if(plot.control$properties[1]){	# if binary#
		result<-prep.binary(distance.matrix, plot.control$points)#
	}else{#
		result<-prep.numeric(distance.matrix, plot.control$points)}#
#
	# call plot code#
	par(mar=rep(0.5, 4))	# set window attributes#
	plot(x= result$points$x, y= result$points$y, type="n", ann=FALSE, axes=FALSE, asp=1)	# plot#
	draw.curves(result, plot.control) #$points, line.list, line.widths, line.gradient)	# add lines#
	points(result$points$x, result$points$y, 	# add points#
		pch=19, #
		col= result$points$colour, #
		cex= result$points$size)#
	text(result$points$x, result$points$y, label= result$points$label, col="white", cex=0.7)	# label points#
#
	# if(singletons)add.outer.points#
	}#
# simple code to get pretty point colours#
point.attr<-function(distance.matrix)#
	{#
	#library(RColorBrewer)	# to choose an existing palette#
	labels<-as.character(attr(distance.matrix, "Labels"))#
	color.hex<-c(RColorBrewer::brewer.pal(8, "Dark2"), #
		brewer.pal(9, "Set1"),#
		brewer.pal(8, "Set2")#
		)[1:length(labels)]#
	point.attributes<-data.frame(#
			label= labels,#
			colour=color.hex,#
			size=rep(3, length(labels)),#
			stringsAsFactors=FALSE)#
	}
test.points<-matrix(data=rnorm(22), nrow=11, ncol=2)#
test.dist<-as.dist(scale(dist(test.points)))#
#
# make binary matrix from this continuous matrix, for example purposes only#
binary.vector<-cut(as.vector(test.dist), breaks=c(-20, 0, 20), labels=FALSE)-1#
#
# directional binary matrix#
distance.matrix<-matrix(data=rep(binary.vector, 2), 11, 11)#
	rownames(distance.matrix)<-c(1:11)#
	colnames(distance.matrix)<-c(1:11)#
for(i in 1:dim(distance.matrix)[1]){distance.matrix[i, i]<-NA}
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "steelblue"),#
	line.width=2#
	))
distance.matrix
plot.control<-check.plot.control(distance.matrix)#, plot.control)
plot.control
plot.control$properties[1]
# run appropriate prep code#
	if(plot.control$properties[1]){	# if binary#
		result<-prep.binary(distance.matrix, plot.control$points)#
	}else{#
		result<-prep.numeric(distance.matrix, plot.control$points)}
result
circleplot(distance.matrix)#, list(
circleplot(distance.matrix, list(#
	line.cols=c("lightblue2", "steelblue"),#
	line.width=2#
	))
